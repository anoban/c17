/*
The sequence of triangle numbers is generated by adding the natural numbers.
So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

     1: 1
     3: 1,3
     6: 1,2,3,6
    10: 1,2,5,10
    15: 1,3,5,15
    21: 1,3,7,21
    28: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?
*/

#include <assert.h>
#include <stdio.h>
#define WIN32_LEAN_AND_MEAN
#define WIN32_EXTRA_MEAN
#define _DEBUG
#include <Windows.h>

unsigned long long static __forceinline __stdcall nDivisors(unsigned long long triangular_number) {
    unsigned long long ndivisors = 0;

    for (unsigned long long i = 1; i <= triangular_number; ++i)
        if (!(triangular_number % i)) ndivisors++;

    return ndivisors;
}

unsigned long long static __forceinline __stdcall nDivisorsBranchless(unsigned long long triangular_number) {
    unsigned long long ndivisors = 0;

    for (unsigned long long i = 1; i <= triangular_number; ++i) ndivisors += (!(triangular_number % i));

    return ndivisors;
}

/*
There's a cheap trick for this ->
nth triangular number is n(n + 1) / 2
*/

#define nthTriangularNumber(x) ((x) * ((x) + 1) / 2)

unsigned long long static __forceinline __stdcall nthTriangularNo(unsigned long long n) {
    unsigned long long tnum = 0;

    for (unsigned long long i = 1; i <= n; ++i) tnum += i;

    return tnum;
}

int main(void) {
    assert(nthTriangularNo(1) == 1);
    assert(nthTriangularNo(4) == 10);
    assert(nthTriangularNo(5) == 15);
    assert(nthTriangularNo(10) == 55);

    unsigned long long triangular[10000] = { 0U };
    LARGE_INTEGER      t_start, t_stop, t_freq, t_elapsed;
    unsigned long long first_trnum_with_500_ormore_divisors = 0;

    for (unsigned long long i = 0; i < 10000; ++i) triangular[i] = nthTriangularNumber(i + 1);

    QueryPerformanceFrequency(&t_freq);
    QueryPerformanceCounter(&t_start);

    for (unsigned long long i = 0; i < 10000; i += 100) {
        if (nDivisors(triangular[i]) >= 500) {
            first_trnum_with_500_ormore_divisors = triangular[i];
            break;
        }
    }

    QueryPerformanceCounter(&t_stop);
    t_elapsed.QuadPart = t_stop.QuadPart - t_start.QuadPart;
    printf_s("First triangular number with 500 or more divisors is %llu\n", first_trnum_with_500_ormore_divisors);
    printf_s("Computation took %.10Lf milliseconds.\n", ((long double) (t_elapsed.QuadPart * 1000000)) / t_freq.QuadPart * 1000);

    return 0;
}
